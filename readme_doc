Welcome to shell : David

Building the Shell from Sources:
 > make

example output:
 Myshell$ make
 gcc -g3 -Werror -Wall -Wpedantic ExternalCommands.c  InternalCommands.c  MyBash.c  Utilities.c -o myshell

Shell Features:
- I/O Redirection
- Background and Foreground task execution
- Piping input from commands
- Multiple commands execution
- Multiple commands execution with I/O redirection
- Support Interactive and Batch mode

Shell Usage:

 - Interactive Mode:
    - Start the shell using "myshell" executable
    Input: > ./myshell
    output: Myshell$ DAVIDBASH> : This is the expected user prompt
    Now, you can go ahead and enter your commands.
     - Single command:
        - Myshell$ DAVIDBASH> ls -lrt  : Command to list the contents of the current directory.
     - Single commnd with I/O Redirectin
        - Myshell$ DAVIDBASH> ls -lrt > ls.txt : Command to list the contents of the current directory and write the output to a file called "ls.tst"
        - Myshell$ DAVIDBASH> more < ls.txt : Command to list the contents of the current directory and write the output to a file called "ls.tst"
     - Single Command with background execution:
        - Myshell$ DAVIDBASH> ls -lrt&
     - Parallel Commands:
        - Myshell$ DAVIDBASH> ls -lrt & ls -lrt > test.txt & more < ls.txt
     - Piped commands:
        - Myshell$ DAVIDBASH> ls -lrt | wc -l
  - Batch Mode:
     - Start the shell using "myshell" executable and the file containing commands to be executed
      Input: > ./myshell cmd.txt

Help on Topics:
- I/O redirection
The redirection capabilities built into Linux provide you with a robust set of tools used to make all sorts of tasks
easier to accomplish. Whether you’re writing complex software or performing file management through the
command line, knowing how to manipulate the different I/O streams in your environment will greatly
increase your productivity.

Streams
Input and output in the Linux environment is distributed across three streams. These streams are:

standard input (stdin)
standard output (stdout)
standard error (stderr)

The streams are also numbered:

stdin (0)
stdout (1)
stderr (2)

During standard interactions between the user and the terminal, standard input is transmitted through the user’s keyboard.
Standard output and standard error are displayed on the user’s terminal as text. Collectively, the three streams
are referred to as the standard streams.

Standard Input
The standard input stream typically carries data from a user to a program. Programs that expect standard input
usually receive input from a device, such as a keyboard. Standard input is terminated by reaching EOF (end-of-file).
As described by its name, EOF indicates that there is no more data to be read.

To see standard input in action, run the cat program. Cat stands for concatenate, which means to link or combine something.
It is commonly used to combine the contents of two files. When run on its own, cat opens a looping prompt.

cat
After opening cat, type a series of numbers as it is running.

>1
>2
>3
ctrl-d
When you type a number and press enter, you are sending standard input to the running cat program,
which is expecting said input. In turn, the cat program is sending your input back to the terminal display
as standard output.

EOF can be input by the user by pressing ctrl-d. After the cat program receives EOF, it stops.

Standard Output
Standard output writes the data that is generated by a program. When the standard output stream is not redirected,
it will output text to the terminal. Try the following example:

echo Sent to the terminal through standard output
When used without any additional options, the echo command displays any argument that is passed to it on the command line.
An argument is something that is received by a program.

Run echo without any arguments:

echo
It will return an empty line, since there are no arguments.

Standard Error
Standard error writes the errors generated by a program that has failed at some point in its execution. Like standard
output, the default destination for this stream is the terminal display.

When a program’s standard error stream is piped to a second program, the piped data (consisting of program errors)
is simultaneously sent to the terminal as well.

Let’s see a basic example of standard error using the ls command. ls lists a directory’s contents.

When run without an argument, ls lists the contents within the current directory. If ls is run with a directory as an
argument, it will list the contents of the provided directory.

ls %
Since % is not an existing directory, this will send the following text to standard error:

ls: cannot access %: No such file or directory
Stream Redirection
Linux includes redirection commands for each stream. These commands write standard output to a file.
If a non-existent file is targetted (either by a single-bracket or double-bracket command), a new file with that
name will be created prior to writing.

Commands with a single bracket overwrite the destination’s existing contents.

Overwrite

> - standard output

< - standard input

2> - standard error

Commands with a double bracket do not overwrite the destination’s existing contents.

Append

>> - standard output

<< - standard input

2>> - standard error


Pipes
Pipes are used to redirect a stream from one program to another. When a program’s standard output is sent to another
through a pipe, the first program’s data, which is received by the second program, will not be displayed on the terminal.
Only the filtered data returned by the second program will be displayed.

The Linux pipe is represented by a vertical bar.

*|*
An example of a command using a pipe:

ls | less
This takes the output of ls, which displays the contents of your current directory, and pipes it to the less program.
less displays the data sent to it one line at a time.

ls normally displays directory contents across multiple rows. When you run it through less, each entry is placed on a new line.

Though the functionality of the pipe may appear to be similar to that of > and >> (standard output redirect),
the distinction is that pipes redirect data from one command to another, while > and >> are used to redirect exclusively to files.


- Background & foreground Execution
Manually control how shell processes execute
As a multitasking operating system, Linux supports the execution of many processes—basically, programs or commands or
similar tasks—in the background while you continue to work in the foreground.

Foreground Processes
A foreground process is any command or task you run directly and wait for it to complete. Some foreground processes
show some type of user interface that supports ongoing user interaction, whereas others execute a task and "freeze"
the computer while it completes that task.

From the shell, a foreground process begins by typing a command at the prompt. For example, to see a simple listing of
the files in the active directory, type:

You'll see the list of files. While the computer is preparing and printing that list, you cannot do anything else from
the command prompt. After the list of files prints to standard output, you regain access to the shell prompt.

Background Process
Unlike with a foreground process, the shell does not have to wait for a background process to end before it can
run more processes. Within the limit of the amount of memory available, you can enter many background commands
one after another. To run a command as a background process, type the command and add a space and an ampersand
to the end of the command. For example:

When you issue a command with the concluding ampersand, the shell executes the work, but instead of making you wait
for the command to finish, you'll immediately be returned to the shell. At this point, you can enter another command
for either foreground or background process. Background jobs are run at a lower priority to the foreground jobs.

You will see a message on the screen when a background process finishes.